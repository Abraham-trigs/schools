datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  ADMIN
  MODERATOR
  PRINCIPAL
  VICE_PRINCIPAL
  TEACHER
  ASSISTANT_TEACHER
  COUNSELOR
  LIBRARIAN
  EXAM_OFFICER
  FINANCE
  HR
  RECEPTIONIST
  IT_SUPPORT
  TRANSPORT
  NURSE
  COOK
  CLEANER
  SECURITY
  MAINTENANCE
  STUDENT
  CLASS_REP
  PARENT
  ALUMNI
  AUDITOR
}

model School {
  id        String   @id @default(cuid())
  name      String   @unique
  domain    String   @unique // default domain for generating emails
  email     String   @unique // school's main contact email
  address   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users            User[]
  classes          Class[]
  buses            Bus[]
  finances         Finance[]
  activities       Activity[]
  resources        Resource[]
  Book             Book[]
  applications     Application[]
  StaffApplication StaffApplication[]
  Student          Student[]
}

model User {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  password  String
  role      Role
  schoolId  String
  school    School   @relation(fields: [schoolId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  student      Student?
  staff        Staff?
  LibraryStaff LibraryStaff?

  createdSubjects Subject[]

  application Application? @relation("UserApplication")
}

// prisma/application.prisma
// Models to capture student admission application form data with indexes.

model Student {
  id       String @id @default(cuid())
  userId   String @unique
  user     User   @relation(fields: [userId], references: [id])
  schoolId String
  school   School @relation(fields: [schoolId], references: [id])

  subjects          Subject[]           @relation("StudentSubjects")
  application       Application?        @relation("StudentApplication")
  enrolledAt        DateTime            @default(now())
  Class             Class?              @relation(fields: [classId], references: [id])
  classId           String?
  Exam              Exam[]
  StudentAttendance StudentAttendance[]
  Parent            Parent[]
  Borrow            Borrow[]
  Transaction       Transaction[]
  Purchase          Purchase[]
}

model Application {
  id        String  @id @default(cuid())
  studentId String  @unique
  student   Student @relation("StudentApplication", fields: [studentId], references: [id])
  userId    String  @unique
  user      User    @relation("UserApplication", fields: [userId], references: [id])
  schoolId  String
  school    School  @relation(fields: [schoolId], references: [id])

  surname        String
  firstName      String
  otherNames     String?
  dateOfBirth    DateTime
  nationality    String
  sex            String
  languages      String[]
  grade          String
  mothersTongue  String
  religion       String
  denomination   String?
  hometown       String
  region         String
  profilePicture String?

  wardLivesWith           String
  numberOfSiblings        Int?
  siblingsOlder           Int?
  siblingsYounger         Int?
  postalAddress           String
  residentialAddress      String
  wardMobile              String?
  wardEmail               String?
  emergencyContact        String
  emergencyMedicalContact String?

  medicalSummary    String?
  bloodType         String?
  specialDisability String?

  feesAcknowledged  Boolean   @default(false)
  declarationSigned Boolean   @default(false)
  signature         String?
  submissionDate    DateTime? @default(now())

  classification String?
  submittedBy    String?
  receivedBy     String?
  receivedDate   DateTime?
  remarks        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  previousSchools PreviousSchool[]
  familyMembers   FamilyMember[]

  admissionPaymentId String?
  admissionPayment   AdmissionPayment? @relation(fields: [admissionPaymentId], references: [id])

  @@index([schoolId])
  @@index([grade])
  @@index([submissionDate])
  @@index([feesAcknowledged])
  @@index([schoolId, grade])
  @@index([submissionDate, feesAcknowledged])
}

model PreviousSchool {
  id            String      @id @default(cuid())
  application   Application @relation(fields: [applicationId], references: [id])
  applicationId String
  name          String
  location      String
  startDate     DateTime
  endDate       DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([applicationId])
}

model FamilyMember {
  id                 String      @id @default(cuid())
  application        Application @relation(fields: [applicationId], references: [id])
  applicationId      String
  relation           String // Father / Mother / Guardian
  name               String
  postalAddress      String
  residentialAddress String
  phone              String?
  email              String?
  occupation         String?
  workplace          String?
  religion           String?
  isAlive            Boolean     @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([applicationId])
  @@index([relation])
  @@index([name])
}

model Class {
  id       String    @id @default(cuid())
  name     String
  grade    String
  schoolId String
  school   School    @relation(fields: [schoolId], references: [id])
  students Student[]
  staff    Staff[]
  exams    Exam[] // Fixed: opposite relation for Exam.class
  subjects Subject[] @relation("ClassSubjects") // Fixed: opposite of Subject.classes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, schoolId])
}

model Subject {
  id        String   @id @default(cuid())
  name      String   @unique
  code      String?  @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Make createdById nullable initially to avoid breaking existing rows
  createdById String?
  createdBy   User?   @relation(fields: [createdById], references: [id])

  exams    Exam[]
  staff    Staff[]   @relation("StaffSubjects")
  students Student[] @relation("StudentSubjects") // many-to-many
  classes  Class[]   @relation("ClassSubjects") // many-to-many

  // Many-to-many relation with StaffApplication
  staffApplications StaffApplication[] @relation("StaffApplicationSubjects")
}

model Exam {
  id        String   @id @default(cuid())
  title     String
  studentId String?
  student   Student? @relation(fields: [studentId], references: [id], onDelete: Cascade)
  classId   String?
  class     Class?   @relation(fields: [classId], references: [id])
  subjectId String
  subject   Subject  @relation(fields: [subjectId], references: [id])
  score     Float?
  maxScore  Float?
  date      DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model StaffApplication {
  id       String  @id @default(cuid())
  staffId  String? @unique
  staff    Staff?  @relation(fields: [staffId], references: [id])
  schoolId String
  school   School  @relation(fields: [schoolId], references: [id])

  // Personal Info
  surname        String
  firstName      String
  otherNames     String?
  dateOfBirth    DateTime
  nationality    String
  sex            String
  languages      String[]
  maritalStatus  String?
  religion       String
  denomination   String?
  hometown       String
  region         String
  profilePicture String? // ✅ added profile picture URL

  // Contact Info
  residentialAddress String
  postalAddress      String
  mobile             String?
  email              String?
  emergencyContact   String
  nextOfKin          String?

  // Professional Info
  position       String
  departmentId   String?
  department     Department?   @relation(fields: [departmentId], references: [id])
  subjects       Subject[]     @relation("StaffApplicationSubjects")
  hireDate       DateTime?
  salary         Float?
  qualifications String?
  previousJobs   PreviousJob[]

  // Medical Info
  bloodType         String?
  medicalConditions String?
  specialDisability String?

  // Declaration & Office Use
  declarationSigned Boolean  @default(false)
  signature         String?
  submissionDate    DateTime @default(now())
  classification    String?
  submittedBy       String?
  receivedBy        String?
  remarks           String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([schoolId])
  @@index([position])
  @@index([submissionDate])
  @@index([departmentId])
}

model PreviousJob {
  id                 String           @id @default(cuid())
  staffApplication   StaffApplication @relation(fields: [staffApplicationId], references: [id])
  staffApplicationId String
  company            String
  role               String
  startDate          DateTime
  endDate            DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([staffApplicationId])
}

model Staff {
  id        String    @id @default(cuid())
  userId    String    @unique
  user      User      @relation(fields: [userId], references: [id])
  classId   String?
  class     Class?    @relation(fields: [classId], references: [id])
  position  String?
  salary    Float?
  hireDate  DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  department   Department? @relation(fields: [departmentId], references: [id])
  departmentId String?

  subjects         Subject[]         @relation("StaffSubjects") // optional: subjects they teach
  attendances      StaffAttendance[]
  StaffApplication StaffApplication?
}

model Department {
  id               String             @id @default(cuid())
  name             String             @unique
  staff            Staff[]
  LibraryStaff     LibraryStaff[]
  StaffApplication StaffApplication[]
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  EXCUSED
}

model StudentAttendance {
  id        String           @id @default(cuid())
  studentId String
  student   Student          @relation(fields: [studentId], references: [id], onDelete: Cascade)
  date      DateTime         @default(now())
  status    AttendanceStatus
  timeIn    DateTime?
  timeOut   DateTime?
  remarks   String?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  @@unique([studentId, date], name: "studentId_date")
}

model StaffAttendance {
  id        String           @id @default(cuid())
  staffId   String
  staff     Staff            @relation(fields: [staffId], references: [id], onDelete: Cascade)
  date      DateTime         @default(now())
  status    AttendanceStatus
  timeIn    DateTime?
  timeOut   DateTime?
  remarks   String?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
}

model Parent {
  id             String   @id @default(cuid())
  studentId      String
  student        Student  @relation(fields: [studentId], references: [id], onDelete: Cascade)
  name           String
  email          String   @unique
  phone          String?
  profilePicture String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

// prisma/library.prisma
// Library management models integrated with Department and School

model Author {
  id        String   @id @default(cuid())
  name      String
  bio       String?
  books     Book[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Category {
  id        String   @id @default(cuid())
  name      String
  books     Book[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Book {
  id          String    @id @default(cuid())
  title       String
  isbn        String    @unique
  authorId    String
  author      Author    @relation(fields: [authorId], references: [id])
  categoryId  String?
  category    Category? @relation(fields: [categoryId], references: [id])
  totalCopies Int       @default(1)
  available   Int       @default(1)
  schoolId    String
  school      School    @relation(fields: [schoolId], references: [id])
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  borrows Borrow[]
}

model Borrow {
  id         String    @id @default(cuid())
  bookId     String
  book       Book      @relation(fields: [bookId], references: [id])
  studentId  String
  student    Student   @relation(fields: [studentId], references: [id], onDelete: Cascade) // ✅ added
  borrowedAt DateTime  @default(now())
  dueAt      DateTime
  returnedAt DateTime?
  fine       Float     @default(0)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@unique([bookId, studentId, borrowedAt], name: "unique_borrow")
}

model LibraryStaff {
  id           String     @id @default(cuid())
  userId       String     @unique
  user         User       @relation(fields: [userId], references: [id])
  departmentId String
  department   Department @relation(fields: [departmentId], references: [id])
  position     String?
  hireDate     DateTime?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
}

//TRANSACTION

enum FinanceType {
  INCOME
  EXPENSE
}

enum FeeType {
  ADMISSION
  TUITION
  EXAM
  LAB
  SPORTS
  LIBRARY
  TRANSPORT
  UNIFORM
  OTHER
}

model AdmissionPayment {
  id          String        @id @default(cuid())
  studentId   String
  schoolId    String
  amount      Float
  pinCode     String        @unique
  used        Boolean       @default(false)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  Application Application[]

  @@index([studentId])
  @@index([schoolId])
  @@index([used])
}

//FINANCE 

model Transaction {
  id          String      @id @default(cuid())
  studentId   String
  student     Student     @relation(fields: [studentId], references: [id], onDelete: Cascade)
  type        FinanceType @default(INCOME)
  feeType     FeeType?
  amount      Float
  date        DateTime    @default(now())
  description String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model Finance {
  id          String      @id @default(cuid())
  schoolId    String
  school      School      @relation(fields: [schoolId], references: [id])
  type        FinanceType @default(INCOME)
  amount      Float
  description String?
  date        DateTime    @default(now())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model Resource {
  id        String   @id @default(cuid())
  name      String
  category  String?
  unitPrice Float
  quantity  Int      @default(1)
  schoolId  String
  school    School   @relation(fields: [schoolId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  purchases Purchase[]

  @@unique([name, schoolId])
}

model Purchase {
  id         String   @id @default(cuid())
  studentId  String
  student    Student  @relation(fields: [studentId], references: [id], onDelete: Cascade) // ✅ added
  resourceId String
  resource   Resource @relation(fields: [resourceId], references: [id])
  quantity   Int      @default(1)
  totalCost  Float
  date       DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

//SCHOOL SCOPE

model Activity {
  id          String   @id @default(cuid())
  title       String
  description String?
  schoolId    String
  school      School   @relation(fields: [schoolId], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Bus {
  id          String   @id @default(cuid())
  schoolId    String
  school      School   @relation(fields: [schoolId], references: [id])
  plateNumber String   @unique
  driverName  String
  capacity    Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// ---------------------------
// Core User / Abraham
// ---------------------------
model Abraham {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  password  String
  role      UserRole
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  projects     Project[]
  tasks        Task[]
  milestones   Milestone[]
  aiContents   AIContent[]
  goals        Goal[]
  chatSessions ChatSession[]
  aiActions    AIAction[]
  cvs          AbrahamCV[]
}

enum UserRole {
  ADMIN
  MODERATOR
  USER
}

// ---------------------------
// Goals & Projects
// ---------------------------
model Goal {
  id          String     @id @default(cuid())
  title       String
  description String
  status      GoalStatus @default(ACTIVE)
  dueDate     DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  owner   Abraham @relation(fields: [ownerId], references: [id])
  ownerId String

  projects  Project[]
  sessions  ChatSession[]
  AbrahamCV AbrahamCV[]
}

enum GoalStatus {
  ACTIVE
  PAUSED
  COMPLETED
}

model Project {
  id          String        @id @default(cuid())
  title       String
  description String
  demoUrl     String?
  stack       String
  status      ProjectStatus @default(ACTIVE)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  owner   Abraham @relation(fields: [ownerId], references: [id])
  ownerId String

  goal   Goal?   @relation(fields: [goalId], references: [id])
  goalId String?

  tasks      Task[]
  milestones Milestone[]
}

enum ProjectStatus {
  ACTIVE
  PAUSED
  COMPLETED
}

// ---------------------------
// Tasks & Milestones
// ---------------------------
model Task {
  id          String      @id @default(cuid())
  project     Project     @relation(fields: [projectId], references: [id])
  projectId   String
  title       String
  description String
  status      TaskStatus  @default(TODO)
  priority    Int         @default(3)
  milestone   Milestone?  @relation(fields: [milestoneId], references: [id])
  milestoneId String?
  aiContent   AIContent[]

  owner   Abraham @relation(fields: [ownerId], references: [id])
  ownerId String
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE
}

model Milestone {
  id            String   @id @default(cuid())
  project       Project  @relation(fields: [projectId], references: [id])
  projectId     String
  title         String
  dueDate       DateTime
  completed     Boolean  @default(false)
  paymentAmount Float
  tasks         Task[]

  owner   Abraham @relation(fields: [ownerId], references: [id])
  ownerId String
}

// ---------------------------
// AI Content & Actions
// ---------------------------
model AIContent {
  id        String   @id @default(cuid())
  task      Task     @relation(fields: [taskId], references: [id])
  taskId    String
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner   Abraham @relation(fields: [ownerId], references: [id])
  ownerId String
}

model AIAction {
  id        String       @id @default(cuid())
  session   ChatSession  @relation(fields: [sessionId], references: [id])
  sessionId String
  message   ChatMessage? @relation(fields: [messageId], references: [id])
  messageId String? // optional link to ChatMessage for undo
  type      AIActionType
  payload   Json
  createdAt DateTime     @default(now())
  Abraham   Abraham?     @relation(fields: [abrahamId], references: [id])
  abrahamId String?
}

enum AIActionType {
  SUBMIT_CV
  ALLOCATE_FUNDS
  CREATE_TASK
  ASK_QUESTION
}

// ---------------------------
// CVs
// ---------------------------
model AbrahamCV {
  id        String   @id @default(cuid())
  user      Abraham  @relation(fields: [userId], references: [id])
  userId    String
  goal      Goal?    @relation(fields: [goalId], references: [id])
  goalId    String?
  content   String
  updatedAt DateTime @updatedAt
}

// ---------------------------
// Chat Sessions & Messages
// ---------------------------
model ChatSession {
  id        String        @id @default(cuid())
  goal      Goal?         @relation(fields: [goalId], references: [id])
  goalId    String?
  owner     Abraham       @relation(fields: [ownerId], references: [id])
  ownerId   String
  messages  ChatMessage[]
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  AIAction  AIAction[]
}

model ChatMessage {
  id            String        @id @default(cuid())
  session       ChatSession   @relation(fields: [sessionId], references: [id])
  sessionId     String
  sender        SenderType
  type          MessageType
  content       String
  actionType    AIActionType? // optional, only for ACTION
  actionPayload Json? // optional JSON payload for ACTION
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  AIAction      AIAction[]
}

enum SenderType {
  USER
  AI
}

enum MessageType {
  USER
  AI
  QUESTION
  ACTION
}
